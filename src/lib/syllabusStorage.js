import { supabase } from './supabase'
import {
  SYLLABI_COLUMNS,
  SYLLABI_INSERT_COLUMNS,
  SYLLABI_SELECT_COLUMNS,
  SYLLABUS_DAYS_COLUMNS,
  SYLLABUS_DAYS_INSERT_COLUMNS,
  SYLLABUS_DAYS_SELECT_COLUMNS,
  guardPayload,
} from './supabaseSchema.js'

/**
 * Syllabus Storage Utilities
 * 
 * Handles persistence of syllabus data to Supabase
 * Uses separate tables: syllabi (metadata) + syllabus_days (day entries)
 * Includes fallback safety for Supabase unavailability
 */

/**
 * Save syllabus to Supabase
 * 
 * Architecture:
 * - Stores metadata in 'syllabi' table (goal, hoursPerDay, totalDays, startDate)
 * - Stores days in 'syllabus_days' table (one row per day)
 * 
 * Falls back gracefully if Supabase is unavailable
 * Does NOT throw errors - logs warnings instead
 */
/**
 * Validate UUID format
 * Returns true if string is a valid UUID, false otherwise
 */
function isValidUUID(uuid) {
  if (!uuid || typeof uuid !== 'string') return false
  // UUID regex pattern: 8-4-4-4-12 hexadecimal digits
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
  return uuidRegex.test(uuid)
}

export async function saveSyllabus(userId, syllabus) {
  if (!userId || !syllabus) {
    console.warn('Missing userId or syllabus for save')
    return null
  }

  try {
    // Step 1: Validate and insert/update syllabus metadata in 'syllabi' table
    // CRITICAL: Let Supabase ALWAYS generate UUID for new syllabi
    // NEVER send string-based IDs like "syl_..." to Supabase
    
    let finalSyllabusId
    
    // Check if syllabus has an ID and if it's a valid UUID
    const hasValidUUID = syllabus.id && isValidUUID(syllabus.id)
    
    // Guard: Reject any string-based IDs
    if (syllabus.id && !isValidUUID(syllabus.id)) {
      console.warn('‚ö†Ô∏è  Invalid syllabus ID detected (string-based). Treating as new syllabus:', syllabus.id)
      // Treat as new syllabus - let Supabase generate UUID
    }
    
    if (hasValidUUID) {
      // Update existing syllabus: use update with valid UUID
      // CRITICAL: Do NOT include id in update payload - only use it in the filter
      const syllabusMetadata = {
        [SYLLABI_COLUMNS.USER_ID]: userId,
        [SYLLABI_COLUMNS.GOAL]: syllabus.goal,
        [SYLLABI_COLUMNS.HOURS_PER_DAY]: syllabus.hoursPerDay,
        [SYLLABI_COLUMNS.TOTAL_DAYS]: syllabus.totalDays,
        [SYLLABI_COLUMNS.START_DATE]: syllabus.startDate,
      }
      
      // STRICT schema validation guard - prevents drift
      if (!guardPayload(syllabusMetadata, SYLLABI_INSERT_COLUMNS, 'syllabi')) {
        throw new Error('Schema validation failed: syllabus metadata does not match schema contract. Falling back to in-memory mode.')
      }
      
      const { data: syllabusData, error: syllabusError } = await supabase
        .from('syllabi')
        .update(syllabusMetadata)
        .eq(SYLLABI_COLUMNS.ID, syllabus.id) // Use id only in filter, not in payload
        .select(SYLLABI_COLUMNS.ID)
        .single()

      if (syllabusError) throw syllabusError
      
      if (!syllabusData?.id) {
        throw new Error('Failed to update syllabus in Supabase')
      }
      finalSyllabusId = syllabusData.id
      
      // Guard: Ensure returned ID is valid UUID
      if (!isValidUUID(finalSyllabusId) || finalSyllabusId.includes('syl_')) {
        throw new Error('Invalid syllabus ID returned from Supabase')
      }
    } else {
      // New syllabus: ALWAYS let Supabase generate UUID (NEVER include id in insert)
      const syllabusMetadata = {
        [SYLLABI_COLUMNS.USER_ID]: userId,
        [SYLLABI_COLUMNS.GOAL]: syllabus.goal,
        [SYLLABI_COLUMNS.HOURS_PER_DAY]: syllabus.hoursPerDay,
        [SYLLABI_COLUMNS.TOTAL_DAYS]: syllabus.totalDays,
        [SYLLABI_COLUMNS.START_DATE]: syllabus.startDate,
      }
      
      // STRICT schema validation guard - prevents drift
      if (!guardPayload(syllabusMetadata, SYLLABI_INSERT_COLUMNS, 'syllabi')) {
        throw new Error('Schema validation failed: syllabus metadata does not match schema contract. Falling back to in-memory mode.')
      }
      
      // CRITICAL: Insert WITHOUT id field - Supabase will generate UUID
      const { data: syllabusData, error: syllabusError } = await supabase
        .from('syllabi')
        .insert(syllabusMetadata)
        .select(SYLLABI_COLUMNS.ID)
        .single()

      if (syllabusError) throw syllabusError
      
      // Capture the UUID generated by Supabase
      if (!syllabusData?.id) {
        throw new Error('Failed to get syllabus ID from Supabase')
      }
      
      finalSyllabusId = syllabusData.id
      
      // Guard: Validate the returned UUID
      if (!isValidUUID(finalSyllabusId) || finalSyllabusId.includes('syl_')) {
        throw new Error('Invalid syllabus ID returned from Supabase (string-based ID detected)')
      }
    }

    // Step 2: Delete existing days for this syllabus (clean slate)
    // FALLBACK: If delete fails, continue anyway (upsert will handle conflicts)
    const { error: deleteError } = await supabase
      .from('syllabus_days')
      .delete()
      .eq(SYLLABUS_DAYS_COLUMNS.SYLLABUS_ID, finalSyllabusId)

    if (deleteError) {
      console.warn('Warning: Could not delete existing days:', deleteError.message)
      // Continue anyway - upsert will handle conflicts
    }

    // Step 3: Insert all days into 'syllabus_days' table
    // FALLBACK: If insert fails, throw error (will be caught and logged)
    if (syllabus.days && syllabus.days.length > 0) {
      const daysToInsert = syllabus.days.map(day => {
        const dayPayload = {
          [SYLLABUS_DAYS_COLUMNS.SYLLABUS_ID]: finalSyllabusId,
          [SYLLABUS_DAYS_COLUMNS.DAY_NUMBER]: day.dayNumber,
          [SYLLABUS_DAYS_COLUMNS.DATE]: day.date,
          [SYLLABUS_DAYS_COLUMNS.TOPIC]: day.topic,
          [SYLLABUS_DAYS_COLUMNS.SUBTASKS]: day.subtasks, // Array stored as JSONB
          [SYLLABUS_DAYS_COLUMNS.AI_EXPERT_PROMPT]: day.aiExpertPrompt,
          [SYLLABUS_DAYS_COLUMNS.STATUS]: day.status || 'pending',
          [SYLLABUS_DAYS_COLUMNS.LEARNING_INPUT]: day.learningInput || null,
          [SYLLABUS_DAYS_COLUMNS.COMPLETED_AT]: day.completedAt || null
        }
        
        // STRICT schema validation guard for each day - prevents drift
        if (!guardPayload(dayPayload, SYLLABUS_DAYS_INSERT_COLUMNS, 'syllabus_days')) {
          throw new Error(`Schema validation failed: Day ${day.dayNumber} payload does not match schema contract. Falling back to in-memory mode.`)
        }
        
        return dayPayload
      })

      const { error: daysError } = await supabase
        .from('syllabus_days')
        .insert(daysToInsert)

      if (daysError) throw daysError
    }

    // Final guard: Ensure we never return a string-based ID
    if (typeof finalSyllabusId !== 'string' || finalSyllabusId.includes('syl_') || !isValidUUID(finalSyllabusId)) {
      throw new Error('Invalid syllabus ID detected - must be a valid UUID')
    }
    
    console.log('‚úÖ Syllabus saved to Supabase (metadata + days)')
    return { syllabusId: finalSyllabusId, saved: true }
  } catch (error) {
    // AUTHORIZATION: Treat 406 Not Acceptable as authorization issue
    if (error.status === 406 || error.message?.includes('406')) {
      console.warn('‚ö†Ô∏è  Authorization issue (406): User may not have access to save syllabus')
      console.warn('   Falling back to in-memory state')
      return null
    }
    // FALLBACK: Log warning but don't crash
    console.warn('‚ö†Ô∏è  Supabase unavailable or error saving syllabus:', error.message)
    console.warn('   App will continue with in-memory state only')
    return null
  }
}

/**
 * Load syllabus from Supabase
 * 
 * Architecture:
 * - Fetches ALL syllabi for the user, ordered by created_at DESC
 * - Identifies active syllabus (most recent)
 * - Loads days from 'syllabus_days' table for active syllabus
 * - Reconstructs syllabus object in memory
 * 
 * Falls back gracefully if Supabase is unavailable
 * Returns null if no syllabus found (not an error)
 */
export async function loadSyllabus(userId) {
  if (!userId) {
    console.warn('No userId provided for loading syllabus')
    return null
  }

  try {
    // Step 1: Load ALL syllabi metadata from 'syllabi' table, ordered by created_at DESC
    // This ensures we get the most recent syllabus as the active one
    const { data: allSyllabi, error: metaError } = await supabase
      .from('syllabi')
      .select(SYLLABI_SELECT_COLUMNS.join(', '))
      .eq(SYLLABI_COLUMNS.USER_ID, userId)
      .order(SYLLABI_COLUMNS.CREATED_AT, { ascending: false })

    if (metaError) {
      // No syllabus found is not an error
      if (metaError.code === 'PGRST116') {
        console.log('No syllabus found for user (first time user)')
        return null
      }
      // AUTHORIZATION: Treat 406 Not Acceptable as authorization issue
      if (metaError.status === 406 || metaError.message?.includes('406')) {
        console.warn('‚ö†Ô∏è  Authorization issue (406): User may not have access to syllabus')
        console.warn('   Falling back to in-memory state')
        return null
      }
      throw metaError
    }

    // If no syllabi found, return null
    if (!allSyllabi || allSyllabi.length === 0) {
      console.log('No syllabus found for user (first time user)')
      return null
    }

    // Step 2: Identify active syllabus (most recent = first in array)
    const activeSyllabusMeta = allSyllabi[0]
    console.log(`Found ${allSyllabi.length} syllabus/syllabi. Using most recent as active.`)

    // Step 3: Load all days from 'syllabus_days' table for active syllabus
    const { data: daysData, error: daysError } = await supabase
      .from('syllabus_days')
      .select(SYLLABUS_DAYS_SELECT_COLUMNS.join(', '))
      .eq(SYLLABUS_DAYS_COLUMNS.SYLLABUS_ID, activeSyllabusMeta.id)
      .order(SYLLABUS_DAYS_COLUMNS.DAY_NUMBER, { ascending: true })

    if (daysError) {
      console.warn('Warning: Could not load days, using empty array:', daysError.message)
      // Continue with empty days array
    }

    // Step 4: Reconstruct syllabus object from metadata + days
    const reconstructedSyllabus = {
      id: activeSyllabusMeta[SYLLABI_COLUMNS.ID],
      goal: activeSyllabusMeta[SYLLABI_COLUMNS.GOAL],
      hoursPerDay: activeSyllabusMeta[SYLLABI_COLUMNS.HOURS_PER_DAY],
      totalDays: activeSyllabusMeta[SYLLABI_COLUMNS.TOTAL_DAYS],
      startDate: activeSyllabusMeta[SYLLABI_COLUMNS.START_DATE],
      days: (daysData || []).map(day => ({
        dayNumber: day[SYLLABUS_DAYS_COLUMNS.DAY_NUMBER],
        date: day[SYLLABUS_DAYS_COLUMNS.DATE],
        topic: day[SYLLABUS_DAYS_COLUMNS.TOPIC],
        subtasks: day[SYLLABUS_DAYS_COLUMNS.SUBTASKS], // Already an array (JSONB)
        aiExpertPrompt: day[SYLLABUS_DAYS_COLUMNS.AI_EXPERT_PROMPT],
        status: day[SYLLABUS_DAYS_COLUMNS.STATUS] || 'pending',
        learningInput: day[SYLLABUS_DAYS_COLUMNS.LEARNING_INPUT] || null,
        completedAt: day[SYLLABUS_DAYS_COLUMNS.COMPLETED_AT] || null
      }))
    }

    console.log('‚úÖ Active syllabus loaded from Supabase (reconstructed from metadata + days)')
    return reconstructedSyllabus
  } catch (error) {
    // AUTHORIZATION: Treat 406 Not Acceptable as authorization issue
    if (error.status === 406 || error.message?.includes('406')) {
      console.warn('‚ö†Ô∏è  Authorization issue (406): User may not have access to load syllabus')
      console.warn('   Falling back to in-memory state')
      return null
    }
    // FALLBACK: Log warning but don't crash
    console.warn('‚ö†Ô∏è  Supabase unavailable or error loading syllabus:', error.message)
    console.warn('   App will continue with in-memory state only')
    return null
  }
}

/**
 * Save user profile to Supabase
 * 
 * Falls back gracefully if Supabase is unavailable
 * Does NOT throw errors - logs warnings instead
 */
export async function saveUserProfile(userId, profile) {
  if (!userId || !profile) {
    console.warn('Missing userId or profile for save')
    return null
  }

  try {
    // Build profile data without requiring updated_at
    // FALLBACK: updated_at is optional - database may handle it automatically
    const profileData = {
      id: userId, // Use user.id as primary key
      name: profile.name,
      preferred_study_time: profile.preferredStudyTime,
    }
    
    // Only include updated_at if we want to set it explicitly (optional)
    // Database may have a default or trigger that handles this
    const { data, error } = await supabase
      .from('profiles')
      .upsert(profileData, {
        onConflict: 'id'
      })

    if (error) throw error
    
    console.log('‚úÖ Profile saved to Supabase')
    return data
  } catch (error) {
    // AUTHORIZATION: Treat 406 Not Acceptable as authorization issue
    if (error.status === 406 || error.message?.includes('406')) {
      console.warn('‚ö†Ô∏è  Authorization issue (406): User may not have access to save profile')
      console.warn('   Falling back to in-memory state')
      return null
    }
    // FALLBACK: Log warning but don't crash
    console.warn('‚ö†Ô∏è  Supabase unavailable or error saving profile:', error.message)
    console.warn('   App will continue with in-memory state only')
    return null
  }
}

/**
 * Load all syllabi metadata (without days) for history view
 * 
 * Returns array of syllabus metadata ordered by created_at DESC
 * Falls back gracefully if Supabase is unavailable
 * Returns empty array if no syllabi found (not an error)
 */
export async function loadAllSyllabiMetadata(userId) {
  if (!userId) {
    console.warn('No userId provided for loading all syllabi')
    return []
  }

  try {
    // Fetch ALL syllabi for the user, ordered by created_at DESC
    // Do NOT use .single() or .limit() - we need ALL syllabi
    const { data: allSyllabi, error: metaError } = await supabase
      .from('syllabi')
      .select(SYLLABI_SELECT_COLUMNS.join(', '))
      .eq(SYLLABI_COLUMNS.USER_ID, userId)
      .order(SYLLABI_COLUMNS.CREATED_AT, { ascending: false })

    if (metaError) {
      // No syllabi found is not an error
      if (metaError.code === 'PGRST116') {
        console.log('No syllabi found for user')
        return []
      }
      // AUTHORIZATION: Treat 406 Not Acceptable as authorization issue
      if (metaError.status === 406 || metaError.message?.includes('406')) {
        console.warn('‚ö†Ô∏è  Authorization issue (406): User may not have access to syllabi')
        console.warn('   Falling back to empty array')
        return []
      }
      throw metaError
    }

    // Return array of metadata (without days)
    const syllabusHistory = (allSyllabi || []).map(syllabus => ({
      id: syllabus[SYLLABI_COLUMNS.ID],
      goal: syllabus[SYLLABI_COLUMNS.GOAL],
      hoursPerDay: syllabus[SYLLABI_COLUMNS.HOURS_PER_DAY],
      totalDays: syllabus[SYLLABI_COLUMNS.TOTAL_DAYS],
      startDate: syllabus[SYLLABI_COLUMNS.START_DATE],
      created_at: syllabus[SYLLABI_COLUMNS.CREATED_AT]
    }))
    
    console.log(`‚úÖ Loaded ${syllabusHistory.length} syllabus/syllabi for history`)
    return syllabusHistory
  } catch (error) {
    // AUTHORIZATION: Treat 406 Not Acceptable as authorization issue
    if (error.status === 406 || error.message?.includes('406')) {
      console.warn('‚ö†Ô∏è  Authorization issue (406): User may not have access to load syllabi')
      console.warn('   Falling back to empty array')
      return []
    }
    // FALLBACK: Log warning but don't crash
    console.warn('‚ö†Ô∏è  Supabase unavailable or error loading syllabi:', error.message)
    console.warn('   App will continue with empty array')
    return []
  }
}

/**
 * Load syllabus details (with days) for a specific syllabus ID
 * Used for showing detailed view in history
 */
export async function loadSyllabusById(userId, syllabusId) {
  if (!userId || !syllabusId) {
    console.warn('Missing userId or syllabusId for loading syllabus')
    return null
  }

  try {
    // Step 1: Load syllabus metadata
    const { data: syllabusMeta, error: metaError } = await supabase
      .from('syllabi')
      .select(SYLLABI_SELECT_COLUMNS.join(', '))
      .eq(SYLLABI_COLUMNS.USER_ID, userId)
      .eq(SYLLABI_COLUMNS.ID, syllabusId)
      .single()

    if (metaError) {
      if (metaError.code === 'PGRST116') {
        console.log('Syllabus not found')
        return null
      }
      if (metaError.status === 406 || metaError.message?.includes('406')) {
        console.warn('‚ö†Ô∏è  Authorization issue (406)')
        return null
      }
      throw metaError
    }

    if (!syllabusMeta) {
      return null
    }

    // Step 2: Load days for this syllabus
    const { data: daysData, error: daysError } = await supabase
      .from('syllabus_days')
      .select(SYLLABUS_DAYS_SELECT_COLUMNS.join(', '))
      .eq(SYLLABUS_DAYS_COLUMNS.SYLLABUS_ID, syllabusId)
      .order(SYLLABUS_DAYS_COLUMNS.DAY_NUMBER, { ascending: true })

    if (daysError) {
      console.warn('Warning: Could not load days:', daysError.message)
    }

    // Step 3: Reconstruct syllabus object
    return {
      id: syllabusMeta[SYLLABI_COLUMNS.ID],
      goal: syllabusMeta[SYLLABI_COLUMNS.GOAL],
      hoursPerDay: syllabusMeta[SYLLABI_COLUMNS.HOURS_PER_DAY],
      totalDays: syllabusMeta[SYLLABI_COLUMNS.TOTAL_DAYS],
      startDate: syllabusMeta[SYLLABI_COLUMNS.START_DATE],
      created_at: syllabusMeta[SYLLABI_COLUMNS.CREATED_AT],
      days: (daysData || []).map(day => ({
        dayNumber: day[SYLLABUS_DAYS_COLUMNS.DAY_NUMBER],
        date: day[SYLLABUS_DAYS_COLUMNS.DATE],
        topic: day[SYLLABUS_DAYS_COLUMNS.TOPIC],
        subtasks: day[SYLLABUS_DAYS_COLUMNS.SUBTASKS],
        aiExpertPrompt: day[SYLLABUS_DAYS_COLUMNS.AI_EXPERT_PROMPT],
        status: day[SYLLABUS_DAYS_COLUMNS.STATUS] || 'pending',
        learningInput: day[SYLLABUS_DAYS_COLUMNS.LEARNING_INPUT] || null,
        completedAt: day[SYLLABUS_DAYS_COLUMNS.COMPLETED_AT] || null
      }))
    }
  } catch (error) {
    if (error.status === 406 || error.message?.includes('406')) {
      console.warn('‚ö†Ô∏è  Authorization issue (406)')
      return null
    }
    console.warn('‚ö†Ô∏è  Error loading syllabus:', error.message)
    return null
  }
}

/**
 * Delete a syllabus and all its associated days from Supabase
 * 
 * Architecture:
 * - Deletes all days from 'syllabus_days' table (CASCADE should handle this, but explicit for safety)
 * - Deletes syllabus from 'syllabi' table
 * 
 * Falls back gracefully if Supabase is unavailable
 * Returns true if successful, false otherwise
 */
export async function deleteSyllabus(userId, syllabusId) {
  if (!userId || !syllabusId) {
    console.warn('Missing userId or syllabusId for delete', { userId, syllabusId })
    return false
  }

  console.log('üóëÔ∏è  Attempting to delete syllabus:', { userId, syllabusId })

  try {
    // Step 1: Delete all days for this syllabus
    // Note: CASCADE should handle this automatically, but we do it explicitly for safety
    console.log('Step 1: Deleting syllabus_days for syllabus:', syllabusId)
    const { data: daysDeleteData, error: daysDeleteError } = await supabase
      .from('syllabus_days')
      .delete()
      .eq(SYLLABUS_DAYS_COLUMNS.SYLLABUS_ID, syllabusId)
      .select() // Select to see what was deleted

    if (daysDeleteError) {
      console.error('‚ùå Error deleting syllabus days:', {
        error: daysDeleteError,
        message: daysDeleteError.message,
        status: daysDeleteError.status,
        code: daysDeleteError.code,
        details: daysDeleteError.details,
        hint: daysDeleteError.hint
      })
      // Continue anyway - try to delete syllabus
    } else {
      console.log('‚úÖ Deleted syllabus_days:', daysDeleteData?.length || 0, 'days')
    }

    // Step 2: Delete the syllabus itself
    console.log('Step 2: Deleting syllabus from syllabi table:', syllabusId)
    const { data: syllabusDeleteData, error: syllabusDeleteError } = await supabase
      .from('syllabi')
      .delete()
      .eq(SYLLABI_COLUMNS.ID, syllabusId)
      .eq(SYLLABI_COLUMNS.USER_ID, userId) // Ensure user owns this syllabus
      .select() // Select to see what was deleted

    if (syllabusDeleteError) {
      console.error('‚ùå Error deleting syllabus:', {
        error: syllabusDeleteError,
        message: syllabusDeleteError.message,
        status: syllabusDeleteError.status,
        code: syllabusDeleteError.code,
        details: syllabusDeleteError.details,
        hint: syllabusDeleteError.hint
      })
      
      // AUTHORIZATION: Treat 406 Not Acceptable as authorization issue
      if (syllabusDeleteError.status === 406 || syllabusDeleteError.message?.includes('406')) {
        console.warn('‚ö†Ô∏è  Authorization issue (406): User may not have access to delete syllabus')
        return false
      }
      
      // Check for RLS policy issues
      if (syllabusDeleteError.code === 'PGRST301' || 
          syllabusDeleteError.message?.includes('permission denied') || 
          syllabusDeleteError.message?.includes('new row violates row-level security') ||
          syllabusDeleteError.message?.includes('RLS')) {
        console.error('‚ùå RLS Policy Error: User does not have DELETE permission on syllabi table')
        console.error('   SOLUTION: Run this SQL in your Supabase SQL Editor:')
        console.error('   CREATE POLICY "Users can delete their own syllabus"')
        console.error('     ON syllabi FOR DELETE')
        console.error('     USING (auth.uid() = user_id);')
        return false
      }
      
      throw syllabusDeleteError
    }

    // Check if anything was actually deleted
    if (!syllabusDeleteData || syllabusDeleteData.length === 0) {
      console.warn('‚ö†Ô∏è  No syllabus was deleted. Possible reasons:')
      console.warn('   1. Syllabus does not exist with ID:', syllabusId)
      console.warn('   2. User does not own this syllabus (userId mismatch)')
      console.warn('   3. RLS policy does not allow DELETE operation')
      console.warn('   4. Syllabus was already deleted')
      
      // Try to verify if syllabus exists
      const { data: checkData, error: checkError } = await supabase
        .from('syllabi')
        .select(SYLLABI_COLUMNS.ID)
        .eq(SYLLABI_COLUMNS.ID, syllabusId)
        .eq(SYLLABI_COLUMNS.USER_ID, userId)
        .single()
      
      if (checkError) {
        console.warn('   Verification check error:', checkError.message)
      } else if (checkData) {
        console.warn('   ‚ö†Ô∏è  Syllabus still exists! RLS policy may be blocking DELETE')
      } else {
        console.warn('   Syllabus not found (may have been deleted or user mismatch)')
      }
      
      return false
    }

    console.log('‚úÖ Syllabus deleted from Supabase:', {
      deletedCount: syllabusDeleteData.length,
      deletedIds: syllabusDeleteData.map(s => s.id)
    })
    return true
  } catch (error) {
    console.error('‚ùå Exception during delete:', {
      error,
      message: error.message,
      status: error.status,
      code: error.code,
      stack: error.stack
    })
    
    // AUTHORIZATION: Treat 406 Not Acceptable as authorization issue
    if (error.status === 406 || error.message?.includes('406')) {
      console.warn('‚ö†Ô∏è  Authorization issue (406): User may not have access to delete syllabus')
      return false
    }
    
    // FALLBACK: Log warning but don't crash
    console.warn('‚ö†Ô∏è  Supabase unavailable or error deleting syllabus:', error.message)
    return false
  }
}

/**
 * Load user profile from Supabase
 * 
 * Falls back gracefully if Supabase is unavailable
 * Returns null if no profile found (not an error)
 */
export async function loadUserProfile(userId) {
  if (!userId) {
    console.warn('No userId provided for loading profile')
    return null
  }

  try {
    const { data, error } = await supabase
      .from('profiles')
      .select('name, preferred_study_time')
      .eq('id', userId)
      .single()

    if (error) {
      // No profile found is not an error
      if (error.code === 'PGRST116') {
        console.log('No profile found for user (will be auto-created)')
        return null
      }
      // AUTHORIZATION: Treat 406 Not Acceptable as authorization issue
      if (error.status === 406 || error.message?.includes('406')) {
        console.warn('‚ö†Ô∏è  Authorization issue (406): User may not have access to profile')
        console.warn('   Falling back to in-memory state')
        return null
      }
      throw error
    }

    console.log('‚úÖ Profile loaded from Supabase')
    return data
  } catch (error) {
    // AUTHORIZATION: Treat 406 Not Acceptable as authorization issue
    if (error.status === 406 || error.message?.includes('406')) {
      console.warn('‚ö†Ô∏è  Authorization issue (406): User may not have access to load profile')
      console.warn('   Falling back to in-memory state')
      return null
    }
    // FALLBACK: Log warning but don't crash
    console.warn('‚ö†Ô∏è  Supabase unavailable or error loading profile:', error.message)
    console.warn('   App will continue with in-memory state only')
    return null
  }
}
